
from __future__ import annotations

import bpy
import json
import mathutils
from pathlib import Path
import os
import types

from vray_blender.external.pyparsing import Forward, Word, alphanums, Suppress, Group, infixNotation, oneOf, opAssoc
from vray_blender.lib import sys_utils
from vray_blender.lib.names import Names
from vray_blender.lib.defs import AttrPlugin, AttrListValue, AColor, ExporterContext, PluginDesc
from vray_blender import debug
from vray_blender.exporting import tools

from vray_blender.bin import VRayBlenderLib as vray

# A list of plugins description as read from the json definition files
PLUGINS_DESC = {}

# Key that serves to describe a comment into a *.custom.json plugin description
DESC_COMMENT_KEY = "//Comment"


def getPluginsDescDir():
    return os.path.join(sys_utils.getExporterPath(), "plugins_desc")



def loadPluginDescriptions():
    descDirpath = Path(getPluginsDescDir())

    loadedPlugins = 0
    for descFile in descDirpath.glob("*/*.json"):
        
        isBaseDesc = True

        if str(descFile).endswith(".custom.json"):
            customDescFile = str(descFile)
            
            # Check whether the .custom.json file has a corresponding .json file (the same base name).
            # If not, this means that the custom description is for a plugin that is a variant of another
            # plugin (e.g. as in render channels).  
            baseFilePath = customDescFile[:-len('.custom.json')] + '.json'
            if Path(baseFilePath).exists():
                # Both base and custom plugin description files are for the same variant of a plugins.
                # The plugin will be loaded when its base description file is processed.
                continue

            # Custom description file is for a variant of a plugin. Proceed with loading both the base description
            # and the csutom description
            isBaseDesc = False
        
        if not (pluginDesc := _loadDescFromFile(descFile, isBaseDesc)):
            continue

        if pluginDesc.get('ID') in PLUGINS_DESC:
            # Already loaded
            continue
        
        loadedPlugins += 1

        try:
            pluginID       = pluginDesc.get('ID')
            pluginParams   = pluginDesc.get('Parameters')
            pluginName     = pluginDesc.get('Name')
            pluginType     = pluginDesc.get('Type')
            pluginSubType  = pluginDesc.get('Subtype', "")
            pluginCategory = pluginDesc.get('Category', pluginType) # Category is optional
            pluginIDDesc   = pluginDesc.get('Description', "")
            pluginOptions  = pluginDesc.get('Options', {})
            pluginWidget   = pluginDesc.get('Widget', {})
            pluginNode     = pluginDesc.get('Node', {})
            pluginOutputs  = [p for p in pluginParams if p['type'].startswith('OUTPUT_')]
                            
            pluginDesc = {
                # To match plugin interface
                'DESC'         : pluginIDDesc,
                'ID'           : pluginID,
                'NAME'         : pluginName,
                'SUBTYPE'      : pluginSubType,
                'TYPE'         : pluginType,
                'Category'     : pluginCategory,
                'Parameters'   : pluginParams,
                'Options'      : pluginOptions,
                'Widget'       : pluginWidget,
                'Node'         : pluginNode,
                'Outputs'      : pluginOutputs
            }

            _generateUIConditionEvaluators(pluginDesc)
            PLUGINS_DESC[pluginID] = pluginDesc
        
        except Exception as ex:
            debug.printExceptionInfo(ex, f"Load plugin description from '{descFile}'. Plugin will not be available.")

    return loadedPlugins

# Remove 'comment' keys from Plugin description
def _removeCommentsFromDesc(desc):
    if type(desc) is list:
        for elem in desc:
            _removeCommentsFromDesc(elem)
    elif type(desc) is dict:
        if DESC_COMMENT_KEY in desc:
            del desc[DESC_COMMENT_KEY]
        for key in desc:
            _removeCommentsFromDesc(desc[key])


def _fixInvalidDefaults(desc):
    """ Fix some known invalid values for parameter defaults generated by the VRay pluginingfo tool. """
    for attrDesc in desc['Parameters']:
        attrType = attrDesc.get('type') 

        match attrType:
            case 'ENUM':
                if attrDesc['default'] not in [item[0] for item in attrDesc['items']]:
                    attrDesc['default'] = attrDesc['items'][0][0]
            case None:
                debug.printError(f"Attribute {desc['ID']}::{attrDesc['attr']} has no 'type' field")
            

def _loadDescFromFile(descFile: Path, isBaseDesc: bool):
    def loadDesc(descFile):
        if not descFile.exists():
            return None
        
        with open(descFile, 'r') as file:
            try:
                return json.loads(file.read())
            except Exception as ex:
                debug.printExceptionInfo(ex, f"Failed to load plugin description file {descFile}")
                return None
        
    try:
        if not (pluginDesc := loadDesc(descFile)):
            return
        
        if isBaseDesc:
            # We loaded a base description. If a custom plugin description file is present,
            # load its contents into the custom description
            customDescFile = descFile.with_suffix('.custom.json')
            customDesc = loadDesc(customDescFile)
        else:
            # We loaded is a custom description file. Load the corresponding base description.
            customDesc = pluginDesc
            baseDescFile = descFile.parent / (pluginDesc['BASE'] + '.json')
            if not (pluginDesc := loadDesc(baseDescFile)):
                return
        
        if customDesc:     
            # If a custom description has been loaded, merge its contents into the base description
            _removeCommentsFromDesc(customDesc)
            _mergePluginDesc(pluginDesc, customDesc)

        _fixInvalidDefaults(pluginDesc)
    except Exception as ex:
        debug.printExceptionInfo(ex, f"Failed to load plugin description from {descFile}")
        return

    return pluginDesc


# Parameters that should be overridden if they exist in .custom.json
_OVERRIDABLE_KEYS = ('Name', 'Description', 'Type', 'Subtype', 'Category', 'Widget', 'Node', 'Options')
_ALL_KEYS = _OVERRIDABLE_KEYS + ('ID',)

def _mergePluginDesc(pluginDesc: dict, customDesc: dict):
    """ Merge selected properties from a custom description file. 
        
        The reason not all properties are merged is because this is not a general mechanism for overriding
        plugin property values, but rather augmening the descriptions with missing data.
        The Name and Description properties are exceptions because they only have a meaning
        to the user. 
    """

    # Allow overriding the ID key for plugin variants only (when more than one custom.json
    # file overrides the same .json file)
    keys = _ALL_KEYS if 'BASE' in customDesc else _OVERRIDABLE_KEYS
    
    for key in keys:
        if key in customDesc:
            pluginDesc[key] = customDesc[key]

    newParams = []
    if 'Parameters' in customDesc:
        for customParam in customDesc["Parameters"]:
            origParam = next(iter(p for p in pluginDesc["Parameters"] if p["attr"] ==  customParam["attr"]), None)
            if origParam is not None:
                _mergePluginParam(origParam, customParam)
            else:
                newParams.append(customParam)

        pluginDesc['Parameters'].extend(newParams)    


# Transfer selected properties from custom to original param
def _mergePluginParam(origParam, customParam):
    for key in customParam:
        if (key in origParam) and type(origParam[key]) is dict:
            # Augment existing values of type 'dictionary'
            origParam[key].update(customParam[key])
        else:
            origParam[key] = customParam[key]

        if key == 'default':
            origParam.setdefault('options', {})['overriden_default'] = True


def loadPluginOnModule(plugin, pluginType):
    """ Augment the passed-in 'plugin' object with all properties read from the json plugin definition file
    """
    if pluginType in PLUGINS_DESC:
        pluginDesc = PLUGINS_DESC[pluginType]

        for key in pluginDesc:
            plugin[key] = pluginDesc[key]


def _getActiveWidgetElements(pluginModule):
    if not hasattr(pluginModule, "Widget"):
        return {} 

    def getWidgetRollouts(widget, rollouts):
        if widget.get("layout") == 'ROLLOUT':
            name = getUIFlagName(pluginModule, widget)
            defaultClosed = widget.get("default_closed", True)
            rollouts[name] = defaultClosed
            for w in widget['attrs']:
                getWidgetRollouts(w, rollouts)

    rollouts = {}

    for widgetSection in pluginModule.Widget:
        for widget in pluginModule.Widget[widgetSection]:
            getWidgetRollouts(widget, rollouts)

    return rollouts

def _generateUIConditionEvaluators(pluginDesc: dict):
    """ Generates evaluation functions for the conditions in all widgets of the plugin. """
    for widget in pluginDesc['Widget']['widgets']:
        _generateWidgetConditionEvaluators(widget, pluginDesc)


def _compileConditionForProperty(propName: str, propCond: str, translator: UIConditionConverter, pluginDesc):
    """ Return the compiled evaluation function for the condition """
    try:
        funcCode = translator.toPython(propCond)
        compiledMethod = compile(funcCode, '<string>', 'exec')
        return types.FunctionType(compiledMethod.co_consts[1], globals(), "evaluate")
    except Exception as ex:
        debug.printError(f"Failed to compile condition for {pluginDesc['ID']}::{propName}: {propCond}, exception: {ex}")
        return None


def _generateWidgetConditionEvaluators(widget, pluginDesc):
    """ Compiles an evaluation function for each condition set on a widget's attribute.
        The compiled function is stored in attribute's 'evaluate' field and can be 
        invoked later with a plugin data object as its parameter. 
    """
    translator = UIConditionConverter(pluginDesc)

    # Compile conditions for widget's own properties as any property may have a condition attached
    widgetConditions = [propName for propName in widget if (type(widget[propName]) is dict) and ('cond' in widget[propName])]
    for propName in widgetConditions:
        if compiledFn := _compileConditionForProperty(propName, widget[propName]['cond'], translator, pluginDesc):
            widget[propName]['evaluate'] = compiledFn

    # Compile conditions for widget's attributes
    if not (attrs := widget.get('attrs')):
        return
   
    for attr in attrs:
        if 'layout' in attr:
            # This is a nested widget
            _generateWidgetConditionEvaluators(attr, pluginDesc)
        else:
            for prop in [attr[p] for p in attr if type(attr[p]) is dict and 'cond' in attr[p]]:
                if compiledFn := _compileConditionForProperty(attr['name'], prop['cond'], translator, pluginDesc):
                    prop['evaluate'] = compiledFn
                


def getUIFlagName(pluginModule, widget):
    """ For rollout widgets, return the name of the hidden checkbox which holds 
        the 'open' state of the widget.
    """
    return f"VRay{pluginModule.ID}_{widget.get('name')}"


def getUIFlagNameFromPropGroup(propGroup, widget):
    """ For rollout widgets, return the name of the hidden checkbox which holds 
        the 'open' state of the widget.
    """
    return f"{propGroup.rna_type.name}_{widget.get('name')}"
    

def _attrPluginToVRay(attrPlugin: AttrPlugin):
    """ Convert AttrPlugin to vray.AttrPlugin """
    output = attrPlugin.output if attrPlugin.output is not None else ''
    return vray.AttrPlugin(attrPlugin.name, output)


def updateValue(renderer, pluginName, attrName, val, subtype=None):
    if type(val) is bool or type(val) is int:
        vray.pluginUpdateInt(renderer, pluginName, attrName, int(val)) 

    elif type(val) is float:
        vray.pluginUpdateFloat(renderer, pluginName, attrName, val)

    elif type(val) is mathutils.Matrix:
        if len(val.col) == 4:
            vray.pluginUpdateTransform(renderer, pluginName, attrName, tools.mat4x4ToTuple(val))
        elif len(val.col) == 3:
            vray.pluginUpdateMatrix(renderer, pluginName, attrName, tools.mat3x3ToTuple(val))
        else:
            raise Exception(f"lib_utils.py: Wrong matrix dimensions: {pluginName}::{attrName} = {val.row}x{val.col}")
        
    elif type(val) is mathutils.Vector:
        vray.pluginUpdateVector(renderer, pluginName, attrName, val.x, val.y, val.z) 

    elif type(val) is mathutils.Color:
        if subtype:
            vray.pluginUpdateAColor(renderer, pluginName, attrName, val.r,val.g,val.b, 1.0) 
        else:
            vray.pluginUpdateColor(renderer, pluginName, attrName, val.r,val.g,val.b) 
            
    elif type(val) is str:
        if val == "True":
            vray.pluginUpdateInt(renderer, pluginName, attrName, 1) 
            # TODO: Remove, temp code to see if it ever gets here
            raise Exception(f"lib_utils.py: Bool value as string: {pluginName}::{attrName}")
        if val == "False":
            vray.pluginUpdateInt(renderer, pluginName, attrName, 0) 
            # TODO: Remove, temp code to see if it ever gets here
            raise Exception(f"lib_utils.py: Bool value as string: {pluginName}::{attrName}")

        vray.pluginUpdateString(renderer, pluginName, attrName, val)
    
    elif type(val) is AColor:
        vray.pluginUpdateAColor(renderer, pluginName, attrName, val.r, val.g, val.b, val.a)
    
    elif type(val) is list:
        if len(val) == 0: 
            vray.pluginResetValue(renderer, pluginName, attrName)
        elif type(val[0]) is str:
            vray.pluginUpdateStringList(renderer, pluginName, attrName, val) 
        elif type(val[0]) is int:
            vray.pluginUpdateIntList(renderer, pluginName, attrName, val)
        elif type(val[0]) is float:
            vray.pluginUpdateFloatList(renderer, pluginName, attrName, val)
        elif type(val[0]) is AttrPlugin:
            # Currently, plugin lists do not support setting a non-default output for the individual
            # plugins, this is why the output is set to empty.
            convertedList = [vray.AttrPlugin(p.name, '') for p in val]
            vray.pluginUpdatePluginList(renderer, pluginName, attrName, convertedList)
        else:
            debug.printError(f"List type not registered with exporter: List[{type(val[0]).__name__}], pluginName: {pluginName}, attr: {attrName}")
    
    elif type(val) is AttrPlugin:
        vray.pluginUpdatePluginDesc(renderer, pluginName, attrName, _attrPluginToVRay(val), val.forceUpdate)

    elif type(val) is AttrListValue:
        vray.pluginUpdateList(renderer, pluginName, attrName, val.attrList, val.attrType)

    else:
        debug.printError(f"Type not registered with exporter: {type(val)}, pluginName: {pluginName}, attr: {attrName}")
        return 0

    return 1

def objectToAttrPlugin(obj: bpy.types.Object):
    """ Constructs an AttrPlugin for a scene object. """
    
    if obj is None:
        return AttrPlugin()
    
    assert isinstance(obj, bpy.types.Object)
    
    match obj.type:
        case 'LIGHT':
            # Lights are represented by a LightXXX plugin in the V-Ray scenes
            return AttrPlugin(Names.object(obj))
        case 'MESH'| 'META' | 'SURFACE' | 'FONT' | 'CURVE':
            # Geometry objects are represented by a Node plugin in the V-Ray scene
            return AttrPlugin(Names.vrayNode(Names.object(obj)))   
        case _:
            debug.printWarning(f"Creating AttrPlugin struct for an unknown object type: {obj.type} [{obj.name}]")
            return AttrPlugin()


# Gets list of AttrPlugins from Blender collection of objects
def collectionToPluginList(collection, filterTypes=None):
    if collection:
        return [objectToAttrPlugin(obj) for obj in collection.all_objects \
                if (not filterTypes) or (obj.type in filterTypes)]
    return []


def setIncludeExcludeList(exporterCtx: ExporterContext, pluginDesc: PluginDesc, objSelectorDesc):
    """ Sets properties of plugin that represent geometry objects
        that will be in a list that includes or excludes
        them from generation of a certain result of the rendering (for example generation on GI)

        @param pluginDesc - plugin description in which the list will be written
        @param objSelectorDesc - property of the object selector template

    """
    
    template = getattr(pluginDesc.vrayPropGroup, objSelectorDesc)
    if fnExport := getattr(template, 'exportToPluginDesc', None):
        fnExport(exporterCtx, pluginDesc)



###################################################################
## UI condition parser
###################################################################

class UIConditionGrammar:     
    """ Grammar for parsing UI condition expressions """

    identifier = Word("::" + alphanums + "_")
    equalityOperator = oneOf("!= = < > <= >=")
    value = Word(alphanums)
    comparisonExpr = identifier + equalityOperator + value

    LPAR,RPAR = map(Suppress, '()')     # Don't generate tokens for the paregtheses
    expr = Forward()                    # Enable recursive patterns
    operand = comparisonExpr
    factor = operand | Group(LPAR + expr + RPAR)

    parser = infixNotation(operand,
            [
                (oneOf(','), 2, opAssoc.LEFT),
                (oneOf(';'), 2, opAssoc.LEFT),
            ])
    
    @staticmethod
    def parse(s: str):
        return UIConditionGrammar.parser.parseString(s)
    

class UIConditionConverter:
    """ Parser for translation of V-Ray UI condition format to Python expression """
    
    def __init__(self, pluginDesc: dict):
        """ @param pluginDesc - description read from a json file """
        self.pluginDesc = pluginDesc
        

    def toPython(self, cond: str):
        syntaxTree = UIConditionGrammar.parse(cond).as_list()
        
        if len(syntaxTree) == 1:
            # If there are no nested conditions (no parentheses), the list will have just one element 
            # which itself is the list with the expression's tokens.
            syntaxTree = syntaxTree[0]

        expr = self._parseCompoundExpression(iter(syntaxTree))
        paramNames = [p[len("param_"):] for p in expr.split(" ") if p.startswith('param_')]
        
        funcCode = "def evaluate(plugin, node=None):\n"
        tab = "  "

        # Generate accessor function code for each parameter in the conditional expression. Currently, this
        # is not optimal because conditions for different parameters won't share the accessor function, but will
        # compile their own. 
        for p in paramNames:
            paramCode = ( ""
                f"{tab}result = None\n"
                f"{tab}if node:\n"
                f"{tab}{tab}sock = next((s for s in node.inputs if hasattr(s, 'vray_attr') and (s.vray_attr=='{p}')), None)\n"
                f"{tab}{tab}if sock:\n"
                f"{tab}{tab}{tab}result = sock.value\n"
                f"{tab}if not result:\n"
                f"{tab}{tab}result = plugin.{p}\n"      
                f"{tab}param_{p} = result\n"      
            )

            funcCode += paramCode

        funcCode += f"{tab}return {expr}"
        return funcCode


    def _buildSimpleExpression(self, propNameToken: str, op: str, value: str):
        # The property name is designated in the expression by prepending '::' to it. Get the original name. 
        propName = propNameToken[2:]
        prop = next((p for p in self.pluginDesc['Parameters'] if p['attr'] == propName))

        if not prop:
            raise Exception(f"Error while parsing condition: no such property {self.pluginDesc['ID']}::{propName}")
        
        # All tokens are strings, we need to convert to the actual type for proper evaluation.
        if prop['type'] in ('INT'):
            value = int(value)
        if prop['type'] in ('FLOAT', 'FLOAT_TEXTURE'):
            value = float(value)
        elif prop['type'] == 'BOOL':
            value = bool(int(value))
        else:
            value = f'"{value}"' if value != 'NONE' else None

        if op == "=":
            op = "=="

        # 'plugin' is the name of the variable with the plugin property data.
        return f"param_{propName} {op} {value}"
            

    def _buildLogicExpression(self, lhs: bool, op, rhs: bool):
        match op:
            case ",":
                return f"{lhs} and {rhs}"
            case ";":
                return f"{lhs} or {rhs}"
            

    def _parseSimpleExpression(self, it):
        """ Parse an expression of type 'parameter op value' """
        lhs = next(it)
        if type(lhs) is list:
            # NOTE IMPORTANT: The spaces around the parentheses are essential. They will be used to 
            # split the resulting string into tokens when replacing the parameter names.
            return f"( {self._parseCompoundExpression(iter(lhs))} )"
        
        operator = next(it)
        value = next(it)
        
        return self._buildSimpleExpression(lhs, operator, value)


    def _parseCompoundExpression(self, it):
        """ Parse a compound expression of type 'condition and/or condition' with possible
            nesting using parentheses.
        """
        lhs = None

        while it:
            if lhs is None:
                lhs = self._parseSimpleExpression(it)

            logicOp = next(it, None)
            if not logicOp:
                # No more data
                return lhs

            rhs = self._parseSimpleExpression(it)
            lhs = self._buildLogicExpression(lhs, logicOp, rhs)

        return lhs
    



