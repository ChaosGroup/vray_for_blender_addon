# SPDX-FileCopyrightText: Chaos Software EOOD
#
# SPDX-License-Identifier: GPL-3.0-or-later


from __future__ import annotations

import bpy
import json
import mathutils
from pathlib import Path
import os

from vray_blender import debug
from vray_blender.lib import sys_utils
from vray_blender.lib.defs import AttrPlugin, AttrListValue, AColor, ExporterContext, PluginDesc
from vray_blender.exporting import tools
from vray_blender.lib.names import Names
from vray_blender.lib.condition_processor import UIConditionCompiler
from vray_blender.lib.lib_utils import getLightPluginType
from collections import defaultdict


from vray_blender.bin import VRayBlenderLib as vray

# A list of plugins description as read from the json definition files
PLUGINS_DESC = {}

# A map of {pluginType: [property_list]} with cross-object dependencies
CROSS_DEPENDENCIES = {}

# Key that serves to describe a comment into a *.custom.json plugin description
DESC_COMMENT_KEY = "//Comment"

# Set to True when the env var for disabling AI features is set
DISABLE_GEN_AI = os.getenv("CHAOS_DISABLE_GEN_AI") == "1"

# {pluginType: [attribute_name, ...]} that matches a plugin type to a list of its template attributes
TEMPLATE_ATTRIBUTES = defaultdict(list)

def getPluginsDescDir():
    return os.path.join(sys_utils.getExporterPath(), "plugins_desc")


def loadPluginDescriptions():
    descDirpath = Path(getPluginsDescDir())

    loadedPlugins = 0
    for descFile in descDirpath.glob("*/*.json"):
        isBaseDesc = True

        if str(descFile).endswith(".custom.json"):
            customDescFile = str(descFile)
            # Check whether the .custom.json file has a corresponding .json file (the same base name).
            # If not, this means that the custom description is for a plugin that is a variant of another
            # plugin (e.g. as in render channels).
            baseFilePath = customDescFile[:-len('.custom.json')] + '.json'
            if Path(baseFilePath).exists():
                # Both base and custom plugin description files are for the same variant of a plugins.
                # The plugin will be loaded when its base description file is processed.
                continue

            # Custom description file is for a variant of a plugin. Proceed with loading both the base description
            # and the csutom description
            isBaseDesc = False

        if not (pluginDesc := _loadDescFromFile(descFile, isBaseDesc)):
            continue

        if pluginDesc.get('ID') in PLUGINS_DESC:
            # Already loaded
            continue

        loadedPlugins += 1

        try:
            pluginID       = pluginDesc.get('ID')
            pluginParams   = pluginDesc.get('Parameters')
            pluginName     = pluginDesc.get('Name')
            pluginType     = pluginDesc.get('Type')
            pluginSubType  = pluginDesc.get('Subtype', "")
            pluginCategory = pluginDesc.get('Category', pluginType) # Category is optional
            pluginIDDesc   = pluginDesc.get('Description', "")
            pluginOptions  = pluginDesc.get('Options', {})
            pluginWidget   = pluginDesc.get('Widget', {})
            pluginNode     = pluginDesc.get('Node', {})
            pluginOutputs  = [p for p in pluginParams if p['type'].startswith('OUTPUT_')]
                            
            pluginDesc = {
                # To match plugin interface
                'DESC'         : pluginIDDesc,
                'ID'           : pluginID,
                'NAME'         : pluginName,
                'SUBTYPE'      : pluginSubType,
                'TYPE'         : pluginType,
                'Category'     : pluginCategory,
                'Parameters'   : pluginParams,
                'Options'      : pluginOptions,
                'Widget'       : pluginWidget,
                'Node'         : pluginNode,
                'Outputs'      : pluginOutputs,
                'SocketPanels' : {}
            }

            UIConditionCompiler(pluginDesc).generateEvaluators()
            _loadSocketPanels(pluginDesc)

            PLUGINS_DESC[pluginID] = pluginDesc
        
        except Exception as ex:
            debug.printExceptionInfo(ex, f"Load plugin description from '{descFile}'. Plugin will not be available.")

    return loadedPlugins

# Remove 'comment' keys from Plugin description
def _removeCommentsFromDesc(desc):
    if type(desc) is list:
        for elem in desc:
            _removeCommentsFromDesc(elem)
    elif type(desc) is dict:
        if DESC_COMMENT_KEY in desc:
            del desc[DESC_COMMENT_KEY]
        for key in desc:
            _removeCommentsFromDesc(desc[key])


def _fixInvalidDefaults(desc):
    """ Fix some known invalid values for parameter defaults generated by the VRay pluginingfo tool. """
    for attrDesc in desc['Parameters']:
        attrType = attrDesc.get('type') 

        match attrType:
            case 'ENUM':
                if attrDesc['default'] not in [item[0] for item in attrDesc['items']]:
                    attrDesc['default'] = attrDesc['items'][0][0]
            case None:
                debug.printError(f"Attribute {desc['ID']}::{attrDesc['attr']} has no 'type' field")
            

def _loadDescFromFile(descFile: Path, isBaseDesc: bool):
    def loadDesc(descFile):
        if not descFile.exists():
            return None
        
        with open(descFile, 'r') as file:
            try:
                return json.loads(file.read())
            except Exception as ex:
                debug.printExceptionInfo(ex, f"Failed to load plugin description file {descFile}")
                return None
        
    try:
        if not (pluginDesc := loadDesc(descFile)):
            return
        
        if isBaseDesc:
            # We loaded a base description. If a custom plugin description file is present,
            # load its contents into the custom description
            customDescFile = descFile.with_suffix('.custom.json')
            customDesc = loadDesc(customDescFile)
        else:
            # We loaded is a custom description file. Load the corresponding base description.
            customDesc = pluginDesc
            baseDescFile = descFile.parent / (pluginDesc['BASE'] + '.json')
            if not (pluginDesc := loadDesc(baseDescFile)):
                return
        
        if customDesc:     
            # If a custom description has been loaded, merge its contents into the base description
            _removeCommentsFromDesc(customDesc)
            _mergePluginDesc(pluginDesc, customDesc)

        _fixInvalidDefaults(pluginDesc)
    except Exception as ex:
        debug.printExceptionInfo(ex, f"Failed to load plugin description from {descFile}")
        return

    return pluginDesc


# Parameters that should be overridden if they exist in .custom.json
_OVERRIDABLE_KEYS = ('Name', 'Description', 'Type', 'Subtype', 'Category', 'Widget', 'Node', 'Options')
_ALL_KEYS = _OVERRIDABLE_KEYS + ('ID',)

def _mergePluginDesc(pluginDesc: dict, customDesc: dict):
    """ Merge selected properties from a custom description file. 
        
        The reason not all properties are merged is because this is not a general mechanism for overriding
        plugin property values, but rather augmening the descriptions with missing data.
        The Name and Description properties are exceptions because they only have a meaning
        to the user. 
    """

    # Allow overriding the ID key for plugin variants only (when more than one custom.json
    # file overrides the same .json file)
    keys = _ALL_KEYS if 'BASE' in customDesc else _OVERRIDABLE_KEYS
    
    for key in keys:
        if key in customDesc:
            pluginDesc[key] = customDesc[key]

    newParams = []
    if 'Parameters' in customDesc:
        for customParam in customDesc["Parameters"]:
            origParam = next(iter(p for p in pluginDesc["Parameters"] if p["attr"] ==  customParam["attr"]), None)
            if origParam is not None:
                _mergePluginParam(origParam, customParam)
            else:
                newParams.append(customParam)

        pluginDesc['Parameters'].extend(newParams)    


# Transfer selected properties from custom to original param
def _mergePluginParam(origParam, customParam):
    for key in customParam:
        if (key in origParam) and type(origParam[key]) is dict:
            # Augment existing values of type 'dictionary'
            origParam[key].update(customParam[key])
        else:
            origParam[key] = customParam[key]

        if key == 'default':
            origParam.setdefault('options', {})['overriden_default'] = True


def loadPluginOnModule(plugin, pluginType):
    """ Augment the passed-in 'plugin' object with all properties read from the json plugin definition file
    """
    if pluginType in PLUGINS_DESC:
        pluginDesc = PLUGINS_DESC[pluginType]

        for key in pluginDesc:
            plugin[key] = pluginDesc[key]


def _getActiveWidgetElements(pluginModule):
    if not hasattr(pluginModule, "Widget"):
        return {} 

    def getWidgetRollouts(widget, rollouts):
        if widget.get("layout") == 'ROLLOUT':
            name = getUIFlagName(pluginModule, widget)
            defaultClosed = widget.get("default_closed", True)
            rollouts[name] = defaultClosed
            for w in widget['attrs']:
                getWidgetRollouts(w, rollouts)

    rollouts = {}

    for widgetSection in pluginModule.Widget:
        for widget in pluginModule.Widget[widgetSection]:
            getWidgetRollouts(widget, rollouts)

    return rollouts


def _loadSocketPanels(pluginDesc: dict):
    """ Load the information about how sockets are grouped into panels on the node """
    if (inputSockets := pluginDesc.get('Node', {}).get('input_sockets', None)) is None:
        return
    
    panelSockets = None

    for sockDesc in inputSockets:
        if sockDesc.get('type', '') == 'ROLLOUT':
            if panelSockets is not None:
                pluginDesc['SocketPanels'][panelSockets[0]] = panelSockets[1]
            panelSockets = (sockDesc['name'], [])
        elif panelSockets is not None:
            panelSockets[1].append(sockDesc['name'])

    if panelSockets is not None:
        pluginDesc['SocketPanels'][panelSockets[0]] = panelSockets[1]



def getUIFlagName(pluginModule, widget):
    """ For rollout widgets, return the name of the hidden checkbox which holds 
        the 'open' state of the widget.
    """
    return f"VRay{pluginModule.ID}_{widget.get('name')}"


def getUIFlagNameFromPropGroup(propGroup, widget):
    """ For rollout widgets, return the name of the hidden checkbox which holds 
        the 'open' state of the widget.
    """
    return f"{propGroup.rna_type.name}_{widget.get('name')}"


def _attrPluginToVRay(attrPlugin: AttrPlugin):
    """ Convert AttrPlugin to vray.AttrPlugin """
    output = attrPlugin.output if attrPlugin.output is not None else ''
    return vray.AttrPlugin(attrPlugin.name, output)


def updateValue(renderer, pluginName, attrName, val, subtype=None, animatable=True):
    if type(val) is bool or type(val) is int:
        vray.pluginUpdateInt(renderer, pluginName, attrName, int(val), animatable)

    elif type(val) is float:
        vray.pluginUpdateFloat(renderer, pluginName, attrName, val, animatable)

    elif type(val) is mathutils.Matrix:
        if len(val.col) == 4:
            vray.pluginUpdateTransform(renderer, pluginName, attrName, tools.mat4x4ToTuple(val), animatable)
        elif len(val.col) == 3:
            vray.pluginUpdateMatrix(renderer, pluginName, attrName, tools.mat3x3ToTuple(val), animatable)
        else:
            raise Exception(f"lib_utils.py: Wrong matrix dimensions: {pluginName}::{attrName} = {val.row}x{val.col}")

    elif type(val) is mathutils.Vector:
        vray.pluginUpdateVector(renderer, pluginName, attrName, val.x, val.y, val.z, animatable)

    elif type(val) is mathutils.Color:
        if subtype:
            vray.pluginUpdateAColor(renderer, pluginName, attrName, val.r,val.g,val.b, 1.0, animatable)
        else:
            vray.pluginUpdateColor(renderer, pluginName, attrName, val.r,val.g,val.b, animatable)

    elif type(val) is str:
        vray.pluginUpdateString(renderer, pluginName, attrName, val, animatable)

    elif type(val) is AColor:
        vray.pluginUpdateAColor(renderer, pluginName, attrName, val.r, val.g, val.b, val.a, animatable)

    elif type(val) is list:
        if len(val) == 0:
            vray.pluginResetValue(renderer, pluginName, attrName)
        elif type(val[0]) is str:
            vray.pluginUpdateStringList(renderer, pluginName, attrName, val)
        elif type(val[0]) is int:
            vray.pluginUpdateIntList(renderer, pluginName, attrName, val, animatable)
        elif type(val[0]) is float:
            vray.pluginUpdateFloatList(renderer, pluginName, attrName, val, animatable)
        elif type(val[0]) is AttrPlugin:
            # Currently, plugin lists do not support setting a non-default output for the individual
            # plugins, this is why the output is set to empty.
            convertedList = [vray.AttrPlugin(p.name, '') for p in val]
            vray.pluginUpdatePluginList(renderer, pluginName, attrName, convertedList, animatable)
        else:
            debug.printError(f"List type not registered with exporter: List[{type(val[0]).__name__}], pluginName: {pluginName}, attr: {attrName}")

    elif type(val) is AttrPlugin:
        vray.pluginUpdatePluginDesc(renderer, pluginName, attrName, _attrPluginToVRay(val), animatable, val.forceUpdate)

    elif type(val) is AttrListValue:
        vray.pluginUpdateList(renderer, pluginName, attrName, val.attrList, val.attrType, animatable)

    else:
        debug.printError(f"Type not registered with exporter: {type(val)}, pluginName: {pluginName}, attr: {attrName}")
        return 0

    return 1

def objectToAttrPlugin(obj: bpy.types.Object):
    """ Constructs an AttrPlugin for a scene object. """

    if obj is None:
        return AttrPlugin()

    assert isinstance(obj, bpy.types.Object)

    if tools.isObjectVrayScene(obj):
        return AttrPlugin(Names.pluginObject("vrayscene", Names.object(obj)), pluginType='VRayScene')
    
    match obj.type:
        case 'LIGHT':
            # Lights are represented by a LightXXX plugin in the V-Ray scenes
            return AttrPlugin(Names.object(obj), pluginType=getLightPluginType(obj.data))
        case 'MESH'| 'META' | 'SURFACE' | 'FONT' | 'CURVE' | 'CURVES':
            # Geometry objects are represented by a Node plugin in the V-Ray scene
            return AttrPlugin(Names.vrayNode(Names.object(obj)), pluginType='Node')   
        case _:
            debug.printWarning(f"Creating AttrPlugin struct for an unknown object type: {obj.type} [{obj.name}]")
            return AttrPlugin()


# Gets list of AttrPlugins from Blender collection of objects
def collectionToPluginList(collection, filterTypes=None):
    if collection:
        return [objectToAttrPlugin(obj) for obj in collection.all_objects \
                if (not filterTypes) or (obj.type in filterTypes)]
    return []


def setIncludeExcludeList(exporterCtx: ExporterContext, pluginDesc: PluginDesc, objSelectorDesc):
    """ Sets properties of plugin that represent geometry objects
        that will be in a list that includes or excludes
        them from generation of a certain result of the rendering (for example generation on GI)

        @param pluginDesc - plugin description in which the list will be written
        @param objSelectorDesc - property of the object selector template

    """
    
    template = getattr(pluginDesc.vrayPropGroup, objSelectorDesc)
    if fnExport := getattr(template, 'exportToPluginDesc', None):
        fnExport(exporterCtx, pluginDesc)


def stringToIntList(string: str, separator: str):
    if string.strip() == '':
        return []
    
    try:
        return [int(item) for item in string.split(separator)]
    except ValueError:
        return None
    


